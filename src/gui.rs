use crate::archive::{ArchiveManager, ArchiveStats};
use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use tauri::command;
use rand::thread_rng;
use rand::seq::SliceRandom;

#[derive(Debug, Serialize, Deserialize)]
pub struct ErrorResponse {
    pub error: String,
    pub details: Option<String>,
    pub code: String,
}

impl std::fmt::Display for ErrorResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.error)
    }
}

impl std::error::Error for ErrorResponse {
    fn description(&self) -> &str {
        &self.error
    }
    
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        None
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SuccessResponse<T> {
    pub success: bool,
    pub data: T,
}

impl<T> From<T> for SuccessResponse<T> {
    fn from(data: T) -> Self {
        SuccessResponse {
            success: true,
            data,
        }
    }
}

impl From<anyhow::Error> for ErrorResponse {
    fn from(error: anyhow::Error) -> Self {
        let error_msg = error.to_string();
        let (code, fun_message) = if error_msg.contains("No such file") || error_msg.contains("does not exist") {
            ("FILE_NOT_FOUND", get_file_not_found_message())
        } else if error_msg.contains("Permission denied") {
            ("PERMISSION_DENIED", get_permission_denied_message())
        } else if error_msg.contains("Invalid ZIP") || error_msg.contains("corrupt") || error_msg.contains("invalid Zip archive") || error_msg.contains("Could not find EOCD") {
            ("INVALID_ARCHIVE", get_invalid_archive_message())
        } else if error_msg.contains("No space left") {
            ("DISK_FULL", get_disk_full_message())
        } else {
            ("UNKNOWN_ERROR", get_unknown_error_message())
        };

        ErrorResponse {
            error: fun_message.to_string(),
            details: Some(format!("Technical details: {error_msg}")),
            code: code.to_string(),
        }
    }
}

// Safe wrapper for all GUI operations
fn safe_execute<T, F>(operation: F) -> std::result::Result<SuccessResponse<T>, ErrorResponse>
where
    F: FnOnce() -> Result<T>,
    T: serde::Serialize,
{
    match std::panic::catch_unwind(std::panic::AssertUnwindSafe(operation)) {
        Ok(Ok(result)) => Ok(result.into()),
        Ok(Err(e)) => {
            eprintln!("Operation failed: {e}");
            Err(e.into())
        }
        Err(panic) => {
            let panic_msg = if let Some(s) = panic.downcast_ref::<&str>() {
                s.to_string()
            } else if let Some(s) = panic.downcast_ref::<String>() {
                s.clone()
            } else {
                "Unknown panic occurred".to_string()
            };
            
            eprintln!("Panic caught: {panic_msg}");
            Err(ErrorResponse {
                error: "Internal error occurred".to_string(),
                details: Some(panic_msg),
                code: "PANIC".to_string(),
            })
        }
    }
}

#[command]
pub async fn create_archive(
    archive_path: String,
    files: Vec<String>,
) -> std::result::Result<SuccessResponse<String>, ErrorResponse> {
    safe_execute(|| {
        // Input validation
        if archive_path.trim().is_empty() {
            return Err(anyhow::anyhow!("Archive path cannot be empty"));
        }
        
        if files.is_empty() {
            return Err(anyhow::anyhow!("No files provided for archiving"));
        }
        
        // Validate file paths
        for file in &files {
            if file.trim().is_empty() {
                return Err(anyhow::anyhow!("Invalid file path provided"));
            }
        }
        
        let manager = ArchiveManager::new();
        let archive_path = PathBuf::from(archive_path);
        let file_paths: Vec<PathBuf> = files.into_iter().map(PathBuf::from).collect();
        let file_refs: Vec<&PathBuf> = file_paths.iter().collect();
        
        manager.create_archive(&archive_path, &file_refs)?;
        
        Ok(format!("{} Archive created: {}", get_create_success_message(), archive_path.display()))
    })
}

#[command]
pub async fn extract_archive(
    archive_path: String,
    output_dir: String,
) -> std::result::Result<SuccessResponse<String>, ErrorResponse> {
    safe_execute(|| {
        // Input validation
        if archive_path.trim().is_empty() {
            return Err(anyhow::anyhow!("Archive path cannot be empty"));
        }
        
        if output_dir.trim().is_empty() {
            return Err(anyhow::anyhow!("Output directory cannot be empty"));
        }
        
        let manager = ArchiveManager::new();
        let archive_path = PathBuf::from(archive_path);
        let output_dir = PathBuf::from(output_dir);
        
        // Check if archive exists
        if !archive_path.exists() {
            return Err(anyhow::anyhow!("Archive file does not exist: {}", archive_path.display()));
        }
        
        manager.extract_archive(&archive_path, &output_dir)?;
        
        Ok(format!("{} Files extracted to: {}", get_extract_success_message(), output_dir.display()))
    })
}

#[command]
pub async fn list_archive(
    archive_path: String
) -> std::result::Result<SuccessResponse<Vec<String>>, ErrorResponse> {
    safe_execute(|| {
        // Input validation
        if archive_path.trim().is_empty() {
            return Err(anyhow::anyhow!("Archive path cannot be empty"));
        }
        
        let manager = ArchiveManager::new();
        let archive_path = PathBuf::from(archive_path);
        
        // Check if archive exists
        if !archive_path.exists() {
            return Err(anyhow::anyhow!("Archive file does not exist: {}", archive_path.display()));
        }
        
        let contents = manager.list_archive(&archive_path)?;
        Ok(contents)
    })
}

#[command]
pub async fn validate_archive(
    archive_path: String
) -> std::result::Result<SuccessResponse<bool>, ErrorResponse> {
    safe_execute(|| {
        // Input validation
        if archive_path.trim().is_empty() {
            return Err(anyhow::anyhow!("Archive path cannot be empty"));
        }
        
        let manager = ArchiveManager::new();
        let archive_path = PathBuf::from(archive_path);
        
        // Check if archive exists
        if !archive_path.exists() {
            return Err(anyhow::anyhow!("Archive file does not exist: {}", archive_path.display()));
        }
        
        let is_valid = manager.validate_archive(&archive_path)?;
        Ok(is_valid)
    })
}

#[command]
pub async fn get_archive_stats(
    archive_path: String
) -> std::result::Result<SuccessResponse<ArchiveStats>, ErrorResponse> {
    safe_execute(|| {
        // Input validation
        if archive_path.trim().is_empty() {
            return Err(anyhow::anyhow!("Archive path cannot be empty"));
        }
        
        let manager = ArchiveManager::new();
        let archive_path = PathBuf::from(archive_path);
        
        // Check if archive exists
        if !archive_path.exists() {
            return Err(anyhow::anyhow!("Archive file does not exist: {}", archive_path.display()));
        }
        
        let stats = manager.get_archive_stats(&archive_path)?;
        Ok(stats)
    })
}

#[command]
pub async fn calculate_file_hash(
    file_path: String
) -> std::result::Result<SuccessResponse<String>, ErrorResponse> {
    safe_execute(|| {
        // Input validation
        if file_path.trim().is_empty() {
            return Err(anyhow::anyhow!("File path cannot be empty"));
        }
        
        let manager = ArchiveManager::new();
        let file_path = PathBuf::from(file_path);
        
        // Check if file exists
        if !file_path.exists() {
            return Err(anyhow::anyhow!("File does not exist: {}", file_path.display()));
        }
        
        if !file_path.is_file() {
            return Err(anyhow::anyhow!("Path is not a file: {}", file_path.display()));
        }
        
        let hash = manager.calculate_file_hash(&file_path)?;
        Ok(hash)
    })
}

#[command]
pub async fn get_app_info() -> std::result::Result<SuccessResponse<serde_json::Value>, ErrorResponse> {
    safe_execute(|| {
        let info = serde_json::json!({
            "name": "Rusty",
            "version": "0.1.0",
            "description": "Modern ZIP Archiver",
            "author": "Claude Code Assistant",
            "build_time": "unknown",
            "commit": "unknown",
        });
        Ok(info)
    })
}

// Health check command
#[command]
pub async fn health_check() -> std::result::Result<SuccessResponse<String>, ErrorResponse> {
    safe_execute(|| {
        // Test basic functionality
        let manager = ArchiveManager::new();
        
        // Test that we can create a manager instance
        let _ = manager; // Ensure manager is used
        
        Ok(get_health_check_message())
    })
}

// Fun message generators for various operations
fn get_create_success_message() -> &'static str {
    let messages = [
        "üéâ Beep boop! Archive assembled!",
        "üì¶ All packed up like a digital suitcase!",
        "‚ú® Files bundled with love!",
        "ü¶Ä Rustacean magic complete!",
        "üéØ Compression mission accomplished!",
        "üìÅ Your files are now mingling together!",
        "üîß Engineered for awesomeness!",
        "üöÄ Launched into the zip dimension!",
    ];
    
    messages.choose(&mut thread_rng()).unwrap_or(&messages[0])
}

fn get_extract_success_message() -> &'static str {
    let messages = [
        "üé™ Herding llamas...",
        "üîÑ Reticulating splines...", 
        "üó∫Ô∏è Mapping distance from Ypsilanti...",
        "üß¨ Decompressing digital DNA...",
        "üé≠ Unleashing the file spirits...",
        "üîÆ Reading the archive tea leaves...",
        "üé® Painting pixels back to life...",
        "üåü Sprinkling extraction fairy dust...",
        "üé≤ Rolling for file recovery...",
        "‚ö° Channeling extraction energy...",
        "üéØ Precision unpacking engaged...",
        "üîß Reverse-engineering the file puzzle...",
    ];
    
    messages.choose(&mut thread_rng()).unwrap_or(&messages[0])
}

fn get_invalid_archive_message() -> &'static str {
    let messages = [
        "üóëÔ∏è Nothing to see here, just a box of digital trash!",
        "ü§∑ This archive is having an identity crisis!",
        "üö´ Not a valid ZIP file - perhaps it's pretending?",
        "üì¶ This box seems to be empty... or full of mysteries!",
        "üîç File format detective says: 'This ain't it, chief!'",
        "üí≠ Archive.exe has stopped working (because it's not an archive)!",
        "üé≠ This file is cosplaying as a ZIP but fooling nobody!",
        "üå™Ô∏è Archive integrity: somewhere between 'nope' and 'not happening'!",
        "üîÆ The archive oracle says: 'Reply hazy, try again (with a real ZIP)'",
        "ü§ñ ERROR 404: Valid archive not found!",
    ];
    
    messages.choose(&mut thread_rng()).unwrap_or(&messages[0])
}

fn get_file_not_found_message() -> &'static str {
    let messages = [
        "üïµÔ∏è File went on vacation without leaving a forwarding address!",
        "üëª Spooky! That file has vanished into the digital void!",
        "üéØ Target acquired... wait, no, target has escaped!",
        "üîç File playing hide and seek (and winning)!",
        "üöÄ Houston, we have a missing file problem!",
        "üé™ File has joined the circus and left town!",
        "üìç GPS can't locate this file - it's off the grid!",
        "üåå File has transcended to another dimension!",
    ];
    
    messages.choose(&mut thread_rng()).unwrap_or(&messages[0])
}

fn get_permission_denied_message() -> &'static str {
    let messages = [
        "üö™ Access denied! You shall not pass (without proper permissions)!",
        "üîê File is locked tighter than Fort Knox!",
        "üëÆ File bouncer says: 'You're not on the list!'",
        "üé´ Ticket required! Please upgrade your permissions!",
        "üõ°Ô∏è File is under witness protection!",
        "üè∞ The file castle has raised its drawbridge!",
        "üîë Wrong key! Try asking the file owner nicely!",
        "üëë This file belongs to the digital nobility!",
    ];
    
    messages.choose(&mut thread_rng()).unwrap_or(&messages[0])
}

fn get_disk_full_message() -> &'static str {
    let messages = [
        "üíæ Disk is fuller than a Thanksgiving turkey!",
        "üì¶ Storage overflow! Time for digital spring cleaning!",
        "üöÄ Houston, we have a storage problem!",
        "üé™ No more room in the digital circus tent!",
        "üè† File hotel: 'No Vacancy' sign is up!",
        "üìö Digital library is at maximum capacity!",
        "üéí Your digital backpack is bursting at the seams!",
        "üåä Drowning in a sea of ones and zeros!",
    ];
    
    messages.choose(&mut thread_rng()).unwrap_or(&messages[0])
}

fn get_unknown_error_message() -> &'static str {
    let messages = [
        "ü§ñ Beep boop! Something unexpected happened!",
        "üéØ We've encountered a wild error! It's not very effective!",
        "üîß Oops! A digital gremlin got into the machinery!",
        "üé™ The digital circus has gone off-script!",
        "üå™Ô∏è A glitch in the matrix has been detected!",
        "üé≤ The dice of fate rolled a critical failure!",
        "ü¶Ñ A mythical error appeared! (Very rare!)",
        "‚ö° Unexpected plot twist in the file story!",
    ];
    
    messages.choose(&mut thread_rng()).unwrap_or(&messages[0])
}

fn get_health_check_message() -> String {
    let messages = [
        "üí™ Feeling strong and ready to zip!",
        "ü¶Ä Rustacean health: Excellent!",
        "‚ö° All systems nominal, captain!",
        "üéØ Locked and loaded for file operations!",
        "üöÄ Ready for launch into archive space!",
        "üîß All gears properly oiled and spinning!",
        "üåü Shining bright like a compressed diamond!",
        "üé™ The archive circus is ready for showtime!",
    ];
    
    messages.choose(&mut thread_rng()).unwrap_or(&messages[0]).to_string()
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[tokio::test]
    async fn test_create_archive_gui() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let test_file = temp_dir.path().join("test.txt");
        let archive_path = temp_dir.path().join("test.zip");

        // Create a test file
        fs::write(&test_file, "Hello, World!")?;

        // Test create command
        let result = create_archive(
            archive_path.to_string_lossy().to_string(),
            vec![test_file.to_string_lossy().to_string()],
        ).await;

        assert!(result.is_ok());
        assert!(archive_path.exists());

        Ok(())
    }

    #[tokio::test]
    async fn test_error_handling() {
        // Test with invalid input
        let result = create_archive("".to_string(), vec![]).await;
        assert!(result.is_err());
        
        let error = result.unwrap_err();
        assert_eq!(error.code, "UNKNOWN_ERROR");
        assert!(!error.error.is_empty());
    }

    #[tokio::test]
    async fn test_safe_execute_panic() {
        let result = safe_execute::<String, _>(|| {
            panic!("Test panic");
        });
        
        assert!(result.is_err());
        let error = result.unwrap_err();
        assert_eq!(error.code, "PANIC");
    }

    #[tokio::test]
    async fn test_health_check() {
        let result = health_check().await;
        assert!(result.is_ok());
        let response = result.unwrap();
        assert!(response.success);
        assert!(!response.data.is_empty());
        // Accept any fun health message rather than expecting a specific one
        assert!(response.data.len() > 10); // Should be a meaningful message
    }

    #[tokio::test]
    async fn test_input_validation() {
        // Test empty archive path
        let result = list_archive("".to_string()).await;
        assert!(result.is_err());
        
        // Test empty file list
        let result = create_archive("test.zip".to_string(), vec![]).await;
        assert!(result.is_err());
        
        // Test nonexistent file
        let result = list_archive("/nonexistent/path.zip".to_string()).await;
        assert!(result.is_err());
    }
}